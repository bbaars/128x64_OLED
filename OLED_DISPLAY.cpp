#include <Wire.h>
#include <SPI.h>
#include "OLED_DISPLAY.h"
#include <stdlib.h>


// RAM Buffer size is dependent on size of our screen (Page 0 of 7, i.e. 16 x 64 = 1024)
static uint8_t buffer[OLED_LCDHEIGHT * OLED_LCDWIDTH / 8] = {

		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xCF, 0x8F,
		0x9F, 0x1F, 0x1F, 0x1F, 0x1F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x1F, 0x7F, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF,
		0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0F, 0x0F, 0x07, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x87, 0x87,
		0xC7, 0xE7, 0xE7, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03,
		0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xC0, 0xF0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x80, 0x80, 0x80, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
		0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF0,
		0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0,
		0xF0, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xF8, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF
};

// Standard Swap function for swapping x and y coordinate
#define OLED_swap(x, y) { int16_t t = x; x = y; y = t; }

// Constructor to initialize our reset pin for I2C
OLED_DISPLAY::OLED_DISPLAY(int8_t reset) {

	// initially initialized to 0, will be changed later.
	_i2cAddr = 0;
	_vccState = 0;

	rst = reset;
}


/*
 * This is the arbritary initialize function that follows the software
 * configuration on the second to last page of the data sheet. The
 * steps are defined below.
 */
void OLED_DISPLAY::init(uint8_t vccstate, uint8_t i2caddr, bool reset) {

	// set our vcc state and i2c address
	_vccState = vccstate;
	_i2cAddr = i2caddr;

	Wire.begin();

	// check our reset pin is valid and we are in the reset mode
	if ((reset) && (rst > 0)) {

		// toggle our RST Pin
		pinMode(rst, OUTPUT);
		digitalWrite(rst, HIGH);

		// Vdd goes to 3.3v at start, wait 1 ms for it to be recognized
		delay(1);

		// bring our reset pin low (Page 27 Power ON Sequence)
		digitalWrite(rst, LOW);

		delay(10);

		// Sequnce 2. "After VDD Becomes stable, set RES# Pin LOW for 3us then HIGH)
		digitalWrite(rst, HIGH);

		// Inital command
		writeCommand(OLED_DISPLAY_OFF);

		// 1. Set Mux Ratio
		writeCommand(OLED_SET_MULTIPLEX); 		// 0x8h
		writeCommand(OLED_LCDHEIGHT - 1);   		// 63d, 64MUX. (Height of our screen)

		//2. Display Offset
		writeCommand(OLED_DISPLAY_OFFSET); 		// 0xD3
		writeCommand(0x0);						// no offset

		// 3. Set Display Start Line
		writeCommand(OLED_STARTLINE);		// 0x40

		// 4. Set Segment Re-Map
		writeCommand(OLED_SEG_REMAP);		// 0xA0
		writeCommand(0xA1);

		// 5. Set COM Output
		writeCommand(OLED_COM_SCAN_DEC);			// 0xC0 (Decrease because your REMAP is starting at 127

		// 6. Set COM Pins Hardware Config
		writeCommand(OLED_SET_COM_PINS);			// 0xDA
		writeCommand(0x12);						// A[4] = 1b (RESET)

		// 7. Set Contrast Control
		writeCommand(OLED_SET_CONTRAST);			// 0x81
		writeCommand(0xCF);						// Contrast from 0 - 256 bytes (this is a guess??)

		// 8. Disable entire Display On
		writeCommand(OLED_DISPLAY_ALL_ON_RESUME);	// 0xA4

		// 9. Set Normal Display
		writeCommand(OLED_NORMALDISPLAY);			// 0xA6

		// 10. Set Osc Frequency
		writeCommand(OLED_SET_DISPLAYCLOCK_DIV); 	// 0xD5
		writeCommand(0x80);							// suggest Ratio for oscillator frequency

		// 11. Enable Charge Pump Regulator
		writeCommand(OLED_CHARGE_PUMP);				// 0x8D
		writeCommand(0x14);							// enable charge pump

		// Set memory addressing mode
		writeCommand(OLED_MEM_MODE);				// 0x20
		writeCommand(0x00);						// Horizontal Addressing Mode

		// Deactivate Scroll
		writeCommand(OLED_DEACTIVATE_SCROLL);

		// 12. Display On
		writeCommand(OLED_DISPLAY_ON);			// 0xAF
	}
}

/*
 * Display function that writes the data to buffer. Must be called
 * each time the screen needs to be updated
 */
void OLED_DISPLAY::display(void) {

	writeCommand(OLED_COL_ADDR);
	writeCommand(0); // column start add ( 0 = reset)

	writeCommand(OLED_LCDWIDTH - 1); // column end address ( 127 = reset)

	writeCommand(OLED_PAGE_ADDR);
	writeCommand(0); // page start addr ( 0 = reset)
	writeCommand(7); // page end addr

	// write our buffer from 0 - 1024 bytes of data
	for (uint16_t i = 0 ; i < (OLED_LCDWIDTH * OLED_LCDHEIGHT / 8); i++) {

		Wire.beginTransmission(_i2cAddr);
		Wire.write(0x40); // Set the RAM Display to the beginning start line register

		for (uint8_t x = 0; x < 16; x++) {
			Wire.write(buffer[i]);
			i++;
		}

		i--;
		Wire.endTransmission();
	}
}

/*
 * Erases the content of the buffer. Must call Display
 * after calling this function
 */
void OLED_DISPLAY::clearDisplay(void) {
	memset(buffer, 0, (OLED_LCDHEIGHT*OLED_LCDWIDTH / 8));
}

/*
 * Writes a command to the specified address in memory
 */
void OLED_DISPLAY::writeCommand(uint8_t command) {

	// starting addr
	uint8_t control = 0x00;

	// start communication with our slave
	Wire.beginTransmission(_i2cAddr);

	// set the starting point to write to
	Wire.write(control);

	// write the command
	Wire.write(command);

	// end the transmission (release the bus)
	Wire.endTransmission();

}

/*
 * Draw a single pixel on the screen
 */
void OLED_DISPLAY::drawPixel(int16_t x, int16_t y, COLOR color) {

	// check the bounds of the pixel before displaying
//	if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
//		return;

	switch(color) {

	case COLOR::WHITE:

		/* There are 128 pixels in each column. If we muliply the y by 128 that 'converts
		 * our point to a 2D point. We then add our x value to shift over
		 */

		// for white we have a 1
		// 0x01 will only display1 pixel
		// could also do |= 0x01
		buffer[(y / 8) * OLED_LCDWIDTH + x] |= 0x01;
		break;

	case COLOR::BLACK:
		// Will AND it with the value that's currently there to apply an all black
		// Could also do (1 << (y&7));
		buffer[(y / 8) * OLED_LCDWIDTH + x] &= 0x00;
		break;

	case COLOR::INVERSE:

		// XOR it with what is there ('opposite' of what is there)
		// is the value is 'ON' then the value will be off because 1 XOR 1 = 0
		// 1 XOR 0 = 1
		buffer[(y / 8) * OLED_LCDWIDTH + x] ^= 0x01;
	}
}

/*
 * private method to get the OLED Width
 *
 * @return width Width of the OLED Screen (pixels)s
 */
uint8_t width() {
	return OLED_LCDWIDTH;
}

/*
 * Private method to get the OLED Height
 *
 * @return height Height of the OLED Screen (pixels)
 */
uint8_t height() {
	return OLED_LCDHEIGHT;
}



